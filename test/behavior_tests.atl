// test atoms
4 -> 4 : Int
45 -> 45

"" -> "" : [Char]
"hi" -> "hi"
"//" -> "//"
"\n\\".; -> <"\n","\\">
"\x02\x20\xaa".; -> <"\x02"," ","\xaa">

// test utf8 encoding chars
"├───╯".; -> <"├","─","─","─","╯">

'a -> 'a
'\n -> '\n
'\0 -> '\0
'\ -> '\\
'" -> '"
'' -> ''
//'-> asdf
'\xff-'\0 -> 255
'\xff -> '\xff
'\0+5 -> '\x05

// Test data form
1 2 -> [1,2]
1 2 3 -> [1,2,3]
(1) -> [1]
(1) (2) -> [[1],[2]]
(1) (2) (3) -> [[1],[2],[3]]
1 2 3+3 -> <4,5,6>
() -> []
() (1) -> [[],[1]]
(1) () -> [[1],[]]
() () -> [[],[]]
(()) -> [[]]
(()) ((1)) -> [[[]],[[1]]]
"asdf" "123" -> ["asdf","123"]

// Test implicit op
1+1 3 -> 6
(1+1)3 -> 6
1 2"b" -> <"1b","2b">
"abc"+0"123" -> "abc123"
("a""c")"d" -> <"ad","cd">
1@2 -> 2
"a"@"b" -> "ba"

// disallowed since not needed
// '\" -> '\"'
// '\' -> '''

/////////////////// test basic ops
5~ -> -5
5~~ -> 5
1+2 -> 3
"a"[+1 -> 'b
1+() -> AtlasTypeError
()%2 -> AtlasTypeError
// leading 0 is separate number
0-12 -> -12
0/12 -> 0
() -> [] : Nil

()[ -> DynamicError
()] -> DynamicError
5;,6> -> [6]
5;> -> []
// todo may want to reconsider and make empty
// () tail -> DynamicError

/////////// test vars
5:v1+v1 -> 10

//////// test infinite list
v1`1:v1 -> [1,1,1,1,1,1,...
v1`'-:v1 -> "-------------...

////////////// test zips
3;,4+1 -> <4,5>
3;,4;,(5;,7)+1 -> <<4,5>,<6,8>>
1+"asdf"% -> "bteg"
"asdf"+1 -> <'b,'t,'e,'g>
(1;,2)+(4;,6,8) -> <5,8>
(4;,6,8)+(1;,2) -> <5,8>

4*5 -> 20

4-1 -> 3
"asdf"-1% -> "`rce"
"abcd"-"aaa"% -> [0,1,2]

10/5 -> 2
9/5 -> 1
11/(5~) -> -3
10/(5~) -> -2
11~/5 -> -3
10~/5 -> -2
10~/(5~) -> 2
9~/(5~) -> 1
1/0 -> DynamicError
0/0 -> DynamicError

10%5 -> 0
9%5 -> 4
11%(5~) -> -4
10%(5~) -> 0
11~%5 -> 4
10~%5 -> 0
10~%(5~) -> 0
9~%(5~) -> -4
//% "abcd" 2 -> [1,0,1,0]
5%0 -> DynamicError

"abcd";,"xzy" [ -> "abcd"
"abcd";,"xzy".[% -> "ax"
"abcd";,"xzy".]% -> "dy"
"abcd";,"xzy"..[%% -> AtlasTypeError

"abcd";,"xzy" > -> ["xzy"]
"abcd";,"xzy".tail -> <"bcd","zy">
'c tail -> AtlasTypeError

"def";,"xzy".`"abc" -> <"adef","bxzy">
"def""xzy"..;`"abc" -> <<"ad","be","cf">,<"ax","bz","cy">>

'a | "asdf" -> <'a,'a,'a,'a>
'  | "asdf"% -> "asdf"
"asdf" | 'a% -> "asdf"
"" | ('a;) -> "a"

0 & 2 | 3 -> 3
1 & 2 | 3 -> 2
() & 2 | 3 -> 3
0; & 2 | 3 -> 2
" "[ & 2 | 3 -> 3
"a"[ & 2 | 3 -> 2

0 & 'a; -> " "
() & 1 -> 0
"" & "asdf" -> ""

1 & 'a | "b" -> <'a>
1 & 'a, | "bcd"% -> "aaa"
"a " . & '1 | "23" % -> "13"

"a b " . & "fghi" | "jklm" % -> "fkhm"
"a b " . & 1 | 0 % -> [1,0,1,0]

1 2.` -> "<1,2>"

"asdf"[(1 2) -> <"a","as">
"abc"; "123".[2 -> <"ab","12">

////////// more advanced circular programming
1 (1+v1%):v1 -> [1,2,3,4,5...
1(1(v1+v2%):v2):v1 -> [1,1,2,3,5,8,13,21...
0 v1+(1(1+v2%):v2)%:v1 -> [1,3,6,10,15...
1+v1:v1 -> AtlasTypeError

//// test more ops and zips
1, -> <1,1,1,1...
"hi".,[5 -> <"hhhhh","iiiii">


1; -> [1]
"hi".; -> <"h","i">
"asdfg"]2 -> "dfg"
"abc"; "123".]2 -> <"c","3">

"hi" "there"_ -> "hithere"
"hi" "there" ("asdf" "123")._ -> <"hithere","asdf123">
1;,%_[5 -> [1,1,1,1,1]

"abc" "123" -> ["abc","123"]
"abc"_("123",%_) -> "abc123123...
"abc",%__"123" -> "abcabcabc...
"123".;`"abc" -> <"a1","b2","c3">
"a"; "b"._("1"; "2") -> <"a1","b2">
'a "b" -> "ab"

1=2 -> []
1=1 -> [1]
'a='a -> "a"
'd=100 -> AtlasTypeError
"abc"="abc" -> ["abc"]
"abc"="abd" -> []
"abc"='a -> <"a","","">
"abc"=('a.) -> AtlasTypeError
"abc".="abd" -> <"a","b","">

"asdf"< -> "asd"
"abc"; "123".< -> <"ab","12">

"abc" "123"\ -> ["a1","b2","c3"]
"abc" "12" "xyz"\ -> ["a1x","b2y","c"]
"abc" "123" ("xyz" "789").\ -> <["a1","b2","c3"],["x7","y8","z9"]>

"abcd";\ -> ["a","b","c","d"]
4\ -> AtlasTypeError
"abc"; "123".;\ -> <["a","b","c"],["1","2","3"]>

// circular programming foldr
4 5 6+(v1> 0):v1[ -> 15

5 const 4 -> AtlasTypeError
//"asdf" const 4 -> AtlasTypeError
5 const "asdf" -> <5,5,5,5>
"asdf" const "123"% -> "asd"

// error and catching
0 (v1<):v1 -> InfiniteLoopError
""[ -> DynamicError
//catch /9 :1:2:0:3;4 -> f

"a b c"&(1 2 3 4 5 6.;)%_ -> [1,3,5]

""~ -> []
" "~ -> []
"-a"~ -> []

'5~ -> AtlasTypeError
'5.~ -> AtlasTypeError

"1 2"; "3 4"~ -> <[1,2],[3,4]>

// !~ "" -> []
// !~ "45 50" -> [45,50]
// !~ "a45 50 a" -> [45,50]
// !~ :"1 2" :"3 4" () -> [[1,2],[3,4]]

// complicated test (primes)
(1+(1 (v2*v1):v1))%(2 (1+v2):v2) & ((),;)|(v2.;;)__ -> [2,3,5,7,11...

// aliases of special zip
//!read "4 5 6" -> [4,5,6]

0,@`(v1+(1 2 3; (4 5 6))):v1] -> <6,15>

(); -> [[]]
();[ -> []

// check incorrect faith attempt
// this would attempt to access invalid elements if said check was not in place
// todo
// 0;. (v1+(3;;):v2) & (4;;[0) | (5;;[0)[:v1` (v2`) -> InfiniteLoopError

// tails' faith example that needed padding before
// todo
//a+1`0:a=10#&a|(b>+1%)%:b[[ -> 19

// Test auto replicating of nil (todo is there another way to test this?)
// "______MA_"='_ !then "CHISTMAS"!; else ()_ -> "CHISTM"


// Test promotion todo these arent' automatic anymore
1(2~) -> [1,-2]
// todo
//'a,; "cd" -> <"ac","ad">
"123".;~ -> <[1],[2],[3]>
// "asdf"\ -> ["a","s","d","f"]


// Test parse uses previous token correct
1 (2~) -> [1,-2]


// implicit value is circular program
(+1@0)[5 -> [0,1,2,3,4]
+(1 2 3 4)@0 -> [0,1,3,6,10]
~+(1 2 3 4)@0 -> [0,1,1,2,2]


// This tests a pathological case in var lookups, would throw before runtime
a:F_F:a -> []

// infinite type
a;:a -> AtlasTypeError

'a-1000 -> 'invalid char: -903
